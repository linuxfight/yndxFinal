// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package expressions

import (
	"context"
)

const create = `-- name: Create :exec
INSERT INTO expressions (
    id, expr, res, finished, error
) VALUES (
             $1, $2, $3, $4, $5
         )
RETURNING id, expr, res, finished, error
`

type CreateParams struct {
	ID       string
	Expr     string
	Res      float64
	Finished bool
	Error    bool
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) error {
	_, err := q.db.Exec(ctx, create,
		arg.ID,
		arg.Expr,
		arg.Res,
		arg.Finished,
		arg.Error,
	)
	return err
}

const createSchema = `-- name: CreateSchema :exec
CREATE TABLE IF NOT EXISTS expressions (
    id VARCHAR(26) NOT NULL PRIMARY KEY,
    expr TEXT NOT NULL UNIQUE,
    res FLOAT NOT NULL,
    finished BOOLEAN NOT NULL,
    error BOOLEAN NOT NULL
)
`

func (q *Queries) CreateSchema(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createSchema)
	return err
}

const getAll = `-- name: GetAll :many
SELECT id, expr, res, finished, error FROM expressions
ORDER BY id DESC
`

func (q *Queries) GetAll(ctx context.Context) ([]Expression, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expression
	for rows.Next() {
		var i Expression
		if err := rows.Scan(
			&i.ID,
			&i.Expr,
			&i.Res,
			&i.Finished,
			&i.Error,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByExpr = `-- name: GetByExpr :one
SELECT id, expr, res, finished, error FROM expressions
WHERE expr = $1 LIMIT 1
`

func (q *Queries) GetByExpr(ctx context.Context, expr string) (Expression, error) {
	row := q.db.QueryRow(ctx, getByExpr, expr)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Expr,
		&i.Res,
		&i.Finished,
		&i.Error,
	)
	return i, err
}

const getById = `-- name: GetById :one
SELECT id, expr, res, finished, error FROM expressions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetById(ctx context.Context, id string) (Expression, error) {
	row := q.db.QueryRow(ctx, getById, id)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Expr,
		&i.Res,
		&i.Finished,
		&i.Error,
	)
	return i, err
}

const update = `-- name: Update :exec
UPDATE expressions
SET res = $1,
    finished = $2,
    error = $3
WHERE id = $4
`

type UpdateParams struct {
	Res      float64
	Finished bool
	Error    bool
	ID       string
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) error {
	_, err := q.db.Exec(ctx, update,
		arg.Res,
		arg.Finished,
		arg.Error,
		arg.ID,
	)
	return err
}
